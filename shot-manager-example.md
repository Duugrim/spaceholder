Payload - объект, содержащий набор данных о траектории снаряда и его уроне. Заменяет weapon в данном контексте, но если weapon - это конкретный предмет, то payload - общее обозначение.
Нужно создать пример json-файла.
``` json
{
  "id": "straight_line",
  "name": "Прямая линия",
  "description": "Классическая прямолинейная траектория без отклонений",
  "type": "linear",
  
  "trajectory": {
    "segments": [
      {
        "type": "line",
        "direction": 0,
        "length": 3,
        "collision": {
          "walls": true,  // Проверять столкновения со стенами
          "tokens": true  // Проверять столкновения с токенами
        },
        "props": {
          "penetration": true, // Может ли пробить
          "ricochet": false    // Может ли срикошетить данный отрезок
        }
      }
    ]
  }
}
```

**Примеры конфигураций collision:**

```json
// Полная проверка (по умолчанию)
"collision": {
  "walls": true,
  "tokens": true
}

// Только стены (игнорировать токены)
"collision": {
  "walls": true,
  "tokens": false
}

// Только токены (проходит сквозь стены)
"collision": {
  "walls": false,
  "tokens": true
}

// Отключить все проверки
"collision": {
  "walls": false,
  "tokens": false
}
```

**Примеры для разных типов сегментов:**

```json
// Взрыв, блокируемый стенами
{
  "type": "circle",
  "range": 3,
  "collision": {
    "walls": true,
    "tokens": false  // Взрыв не блокируется другими токенами
  },
  "props": {}
}

// Конус огня, проходящий сквозь стены
{
  "type": "cone",
  "direction": 0,
  "range": 5,
  "angle": 90,
  "cut": 0,
  "collision": {
    "walls": false,  // Магический огонь проходит сквозь стены
    "tokens": true
  },
  "props": {}
}
```
Алгоритм работы:
1. Пользователь вызывает **startAiming(*token*, *payload*)**. 
2. Запускается режим прицеливания.
3. Результат работы режима прицеливания - вызов функции **createShot(*token*, *payload*, *direction*)**.
4. **createShot** регистрирует новый выстрел в системе `ShotSystem` с новым UID. Можно использовать просто строку вида *shot_{timestamp}* - выстрелы обычно будут происходить раз в несколько секунд, максимум - несколько раз в секунду. Так что timestamp с точностью до миллисекунд должен покрыть наши потребности в UID.
5. `ShotSystem` получает информацию о том, что нужно создать новый выстрел, и создаёт его структуру данных во временном хранилище.
6. **createShot** вызывает функцию **getWhitelist(*token*)**. Данная функция возвращает массив объектов, которые будут игнорироваться при стрельбе. Такие объекты, как стены и токены. Эта логика будет позже, поэтому пока что эта функция должна возвращать пустой массив.
7. **createShot** вызывает функцию **getDefaults(*token*)**. Функция задаёт ряд переменных для дальнейшего использования:
	- *defSize* = grid.size / grid.distance (берётся у сцены, на которой находится токен. Универсальная длина отрезка)
	- *defPos* = текущие координаты токена. Сразу задаётся в *lastPos*
8. Функция **createShot** начинает просчёт выстрела. Она принимает в качестве инструкции *payload* и просчитывает его в направлении *direction* из точки *lastPos*(которая равна *defPos* и находится в центре токена). **createShot** идёт по *payload* следующим образом:
	1. Обращается к первому элементу траектории в *payload*;
	2. Вызывает функцию **shotSegment(*segment\[i\]*, *whitelist*)** в которую подаёт только этот первый сегмент и объект *whitelist*, который содержит список объектов, которые необходимо игнорировать при столкновении.
	3. **shotSegment** - внутренний обработчик, который читает инструкции, предписанные для данного типа сегмента, и разбивает их на более простые задачи. Подробнее в примере;
	4. **shotSegment** создаёт как минимум один простой сегмент через соответствующую функцию, соответствующую типу. Например, **shotLine()** для простой линии;
	5. Простой сегмент возвращает нам информацию о своих координатах. Для простой линии это координаты начала и конца;
	6. После просчёта простого сегмента проверяются попадания через обработчик `HitSystem`, через новый метод **isHit(*segment*, *whitelist*)** - замена для **RayCaster.checkSegmentCollisions**;
	7. **isHit** возвращает нам информацию о том, с чем столкнулся наш сегмент, и продолжаем ли мы путь по какой-либо причине. **isHit** также сохраняет результат попадания в отдельном массиве *actualHits* у выстрела в `ShotSystem`.
		1. Если мы столкнулись со стеной, то мы можем либо остановится, либо пробить её насквозь, либо отскочить от неё, если у нас включены рикошеты у данного **shotSegment**. Если мы рикошетим, то **shotSegment** считает, сколько дистанции осталось в отрезке после рикошета, и вызывает "внеочередной" **shotLine()** с новым направлением и оставшейся дистанцией. 
		   Не забываем сохранить новое направление для следующих сегментов. 
		   Не забываем игнорировать эту стену после поворота.
		2. Если мы столкнулись с токеном, то опять же, **isHit** нам может вернуть разнообразную информацию: завершение всего выстрела, продолжение выстрела, изменение направления.
	8. **shotSegment** обрабатывает результат работы **isHit**, определяя финальные координаты отрезка и набор столкновений, и сохраняет их в объект *shotResult* в данных выстрела в `ShotSystem`. В этом объекте есть два внутренних массива: *shotPaths* и *shotHits*. Например:
		1. Если у нас есть прямой отрезок из \[0,0\] в \[5,5\], но **isHit** нам сообщил, что есть попадание в \[2,2\] и оно финальное, то окончательный результат отрезка будет: начало в \[0,0\], конец в \[2,2\], столкновение в \[2,2\]. 
		2. Если у нас есть прямой отрезок из \[0,0\] в \[5,5\], и **isHit** нам сообщил, что есть попадание в \[2,2\], но оно НЕ финальное, то окончательный результат отрезка будет: начало в \[0,0\], конец в \[5,5\], столкновение в \[2,2\].
		3. Если у нас есть прямой отрезок из \[0,0\] в \[5,5\], и **isHit** нам сообщил, что есть попадание в \[2,2\], но это (в результате вычислений **isHit**) промах, то окончательный результат отрезка будет: начало в \[0,0\], конец в \[5,5\], промах в \[2,2\].
	9. Если тип отрезка более сложный (например, рекурсивная прямая линия), то **shotSegment** продолжает работу, пока инструкции не будут исполнены.
	10. По завершению работы **shotSegment** мы получаем: 
		- координаты конца сегмента;
		- направление, в какую сторону из последней точки должен двигаться следующий сегмент
		- все отрезки уже записаны в `ShotSystem`
		- lastPos в месте, где нужно продолжать траекторию.
9. **createShot** переходит к следующему сегменту в payload и вызывает новый **shotSegment**